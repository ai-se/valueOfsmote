
\documentclass[sigconf,review, anonymous]{acmart}
%\documentclass[10pt,conference]{IEEEtran}
\usepackage{booktabs} % For formal tables
\usepackage{pbox}
\usepackage{csvsimple}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{rotating}
\usepackage{wrapfig}
\usepackage{dblfloatfix}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{blindtext, graphicx}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{float}
\usepackage{balance}
\usepackage{listings}
\renewcommand\thesection{\arabic{section}}
%\renewcommand\thesubsection{\thesection\arabic{subsection}}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{comment}
\usepackage{framed}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{bigstrut}
\usepackage{color}
\usepackage{eqparbox}
\usepackage{graphics}
\usepackage{colortbl}
\usepackage{paralist}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{mathptmx} 
\usepackage{picture}
\usepackage[shortlabels]{enumitem}
\usepackage{url}
\usepackage{pifont}% http://ctan.org/pkg/pifont

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\newcommand{\bi}{\begin{itemize}[leftmargin=0.4cm]}
	\newcommand{\ei}{\end{itemize}}
\newcommand{\be}{\begin{enumerate}}
	\newcommand{\ee}{\end{enumerate}}

\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{hhline}
\usepackage[export]{adjustbox}
\definecolor{lightgray}{gray}{0.8}
\definecolor{darkgray}{gray}{0.6}
\definecolor{lavenderpink}{rgb}{0.98, 0.68, 0.82}
\definecolor{celadon}{rgb}{0.67, 0.88, 0.69}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
%%% graph
\newcommand{\crule}[3][darkgray]{\textcolor{#1}{\rule{#2}{#3}}}

\newcommand{\quart}[4]{\begin{picture}(80,4)%1
	{\color{black}\put(#3,2){\circle*{4}}\put(#1,2){\line(1,0){#2}}}\end{picture}}

\definecolor{Gray}{gray}{0.95}
\definecolor{LightGray}{gray}{0.975}

\definecolor{steel}{rgb}{.11, .11, .7}
\definecolor{Gray}{rgb}{0.88,1,1}
\definecolor{Gray}{gray}{0.85}
\usepackage[framed]{ntheorem}
\usetikzlibrary{shadows}
\theoremclass{Lesson}
\theoremstyle{break}

% inner sep=10pt,
\tikzstyle{thmbox} = [rectangle, rounded corners, draw=black,
fill=Gray!40,  drop shadow={fill=black, opacity=1}]
\newcommand\thmbox[1]{%
	\noindent\begin{tikzpicture}%
	\node [thmbox] (box){%
		\begin{minipage}{.94\textwidth}%
		\vspace{-0.5mm}#1\vspace{-0.5mm}%
		\end{minipage}%
	};%
	\end{tikzpicture}}

\let\theoremframecommand\thmbox
\newshadedtheorem{lesson}{Result}

\theoremclass{Lesson1}
\theoremstyle{break}

\let\theoremframecommand\thmbox
\newshadedtheorem{lesson1}{Result}
\newcommand{\tion}[1]{{Section }\ref{sect:#1}}

\usepackage{listings}
\definecolor{MyDarkBlue}{rgb}{0,0.08,0.45} 
\lstset{
    language=Python,
    basicstyle=\sffamily\fontsize{3mm}{0.9em}\selectfont,
    breaklines=true,
    prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    frame=l,
    keepspaces=false,
    showtabs=false,
    columns=fullflexible,
    showspaces=false,
    showstringspaces=false,
    keywordstyle=\bfseries\sffamily,
    emph={ m, r, k, frontier, cf, f, g, n}, emphstyle=\bfseries\color{blue!50!black},
    stringstyle=\color{green!50!black},
    commentstyle=\color{red!50!black}\it,
    numbers=left,
    captionpos=t,
    escapeinside={\%*}{*)}
}

\DeclareMathOperator\caret{\raisebox{0.4ex}{$\scriptstyle\wedge$}}
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}

\acmDOI{10.475/123_4}
% ISBN
\acmISBN{123-4567-24-567/17/08}
\acmConference[ICSE'18]{International Conference on Software Engineering}{May 2018}{Gothenburg, Sweden} 
\acmYear{2018}
\copyrightyear{2018}

\acmPrice{00.00}

\newcommand{\sma}{{\sc SMOTE}}
\newcommand{\smb}{{\sc SMOTUNED}}

\begin{document}

%\pagestyle{plain}

\title{``Better Data'' is Better than ``Better Data Miners''\\ (Benefits of Tuning SMOTE for Defect Prediction) }

% \author{Amritanshu Agrawal, Tim Menzies\\
% Computer Science, NC State, USA\\
% aagrawa8@ncsu.edu, tim@menzies.us
% }


%\author{Author name(s) blinded for review.}
\author{Amritanshu Agrawal}
\affiliation{Department of Computer Science\\
North Carolina State University\\
Raleigh, NC, USA\\}
\email{aagrawa8@ncsu.edu}

\author{Tim Menzies}
\affiliation{Department of Computer Science\\
North Carolina State University\\
Raleigh, NC, USA\\}
\email{tim@menzies.us}
\pagestyle{plain}

\begin{abstract}
We report and fix an important systematic error in prior
studies that ranked classifiers for software analytics.
Those studies  did  not (a)~assess classifiers on multiple   criteria
and they did not 
(b)~study  how variations in the  data affect the results. 
Hence, 
this paper applies (a)  multi-criteria tests while (b)~fixing the weaker regions of the training
 data (using {\smb}, which is a self-tuning version of {\sma}).
This approach
leads to dramatically large increases in software defect predictions.
When applied in a 5*5 cross-validation study for  3,681	JAVA classes (containing over a million lines of code) from open source  systems,
{\smb} increased
AUC and recall by 60\% and 20\% respectively. 
These improvements were independent of the classifier used to
predict for quality. Same kind of pattern (improvement) was observed when a comparative analysis of {\sma} and {\smb} was done against the most recent class imbalance techniques.

We hence conclude that, for  software analytics, (1)~data
pre-processing can be more important than  classifier
choice,
(2)~ranking studies  are  incomplete  without
 pre-processing and
(3)~{\smb} is a   promising candidate for  pre-processing.

\end{abstract}


%\keywords{
%Performance Prediction, SBSE, Sampling, Rank-based method}



\keywords{Search based SE,
 defect prediction, classification, 
 data analytics for software engineering, SMOTE,  imbalanced data, preprocessing}

\maketitle
%\IEEEpeerreviewmaketitle


\section{Introduction}
\label{sect:intro}

Software quality methods cost money and better quality costs exponentially more money ~\cite{voas95, fu2016tuning}. Given finite budgets, quality assurance resources are usually 
skewed towards areas known to be most safety critical or mission critical~\cite{lowryBK98}. This leaves ``blind spots'': regions of the system that may contain defects which may be missed. Therefore, in addition to rigorously assessing  critical areas, a parallel activity should be to {\em sample the blind spots}~\cite{Menzies04}. 

To sample those blind spots, many researchers  use  {\em static code defect predictors}.
%~\cite{lessmann2008benchmarking, hall2012systematic, elish2008predicting, pears2014synthetic, pelayo2012evaluating, tan2015online, kamei2007effects, pelayo2007applying, menzies2010defect, gondra2008applying, radjenovic2013software, jiang2008techniques, wang2013using, mende2009revisiting, li2012sample, khoshgoftaar2010attribute, jiang2009variance, ghotra2015revisiting, tantithamthavorn2016automated, fu2016tuning, jiang2008can,d2010extensive,menzies2007data, nagappan2006mining,shepperd2014researcher,Menzies2010,hassan2009predicting, kim2007predicting,song2011general, song2006software}.
Source code is divided into sections, researchers annotate the code with the number of issues known for each section.
Classification algorithms are then applied to learn what static code attributes
distinguish 
between sections with few/many issues.
Such static code measures can be automatically extracted from
the code base, with very little effort even for very large software
systems \cite{nagappan2005static}.  


One perennial problem   is what classifier should be applied to build the defect predictors?
To address this problem, numerous papers report {\em ranking studies} where
some quality measure  is collected from  several  classifiers when they are 
 applied to data sets. Such case studies are ~\cite{lessmann2008benchmarking,hall2012systematic,elish2008predicting,menzies2010defect,gondra2008applying,radjenovic2013software,jiang2008techniques,wang2013using,mende2009revisiting,li2012sample,khoshgoftaar2010attribute,jiang2009variance,ghotra2015revisiting,jiang2008can,tantithamthavorn2016automated,fu2016tuning}.
These ranking studies conclude that some subset of the classifiers
are  ``best'' if they generate  better quality scores.
Our claim is that such conclusions are incomplete when
they ignore the impact of  
data pre-processing especially the class imbalance problem. There are various methods to handle data imbalance for e.g., {\sma} \cite{chawla2002smote}, Borderline-SMOTE~\cite{han2005borderline}, ADASYN~\cite{he2008adasyn}, Random Oversampling and No sampling. Bennin et al.~\cite{bennin2017mahakil} studied similar datasets which we have used in this study and found that {\sma} performs better than all the above recent techniques. They also proposed their own method which performed similar to {\sma}. But they did not consider applying an automated tuning method to learn the best SMOTE control parameters. We believe it to be an important factor and we propose,
a new data pre-processing method called {\smb}, which
 consistently generates better 
defect predictors,
{\em regardless of the classifier used
to make the predictions}. Later in the paper we have also compared {\smb} against the Bennin et al. method.


 \begin{table*}[!t]
\renewcommand{\baselinestretch}{0.8}\begin{center}
\caption{OO CK code metrics used for all studies in this paper.
The last line, shown in denotes the dependent variable.}
\label{fig:ck}
{\small
\begin{tabular}{c|l|p{4.4in}}
amc & average method complexity & e.g., number of JAVA byte codes\\
\hline
avg, cc & average McCabe & average McCabe's cyclomatic complexity seen
in class\\
\hline
ca & afferent couplings & how many other classes use the specific
class. \\
\hline
cam & cohesion amongst classes & summation of number of different
types of method parameters in every method divided by a multiplication
of number of different method parameter types in whole class and
number of methods. \\
\hline
cbm &coupling between methods & total number of new/redefined methods
to which all the inherited methods are coupled\\
\hline
cbo & coupling between objects & increased when the methods of one
class access services of another.\\
\hline
ce & efferent couplings & how many other classes is used by the
specific class. \\
\hline
dam & data access & ratio of the number of private (protected)
attributes to the total number of attributes\\
\hline
dit & depth of inheritance tree &\\
\hline
ic & inheritance coupling & number of parent classes to which a given
class is coupled
\\
\hline
lcom & lack of cohesion in methods &number of pairs of methods that do
not share a reference to an case variable.\\
\hline
locm3 & another lack of cohesion measure & if $m,a$ are the number of
$methods,attributes$
in a class number and $\mu(a)$ is the number of methods accessing an
attribute,
then
$lcom3=((\frac{1}{a} \sum, j^a \mu(a, j)) - m)/ (1-m)$.
\\
\hline
loc & lines of code &\\
\hline
max, cc & maximum McCabe & maximum McCabe's cyclomatic complexity seen
in class\\
\hline
mfa & functional abstraction & no. of methods inherited by a class
plus no. of methods accessible by member methods of the
class\\
\hline
moa & aggregation & count of the number of data declarations (class
fields) whose types are user defined classes\\
\hline
noc & number of children &\\
\hline
npm & number of public methods & \\
\hline
rfc & response for a class &number of methods invoked in response to
a message to the object.\\
\hline
wmc & weighted methods per class &\\
\hline
 
nDefects & raw defect counts & Numeric: number of defects found in post-release bug-tracking systems.\\
\rowcolor{lightgray}
defects present? & Boolean& if {\em nDefects} $>0$ then {\em true} else {\em false}
\end{tabular}
}
\end{center}
\vspace{-0.2cm}
\end{table*}


{\smb} is an auto-tuning version of  {\sma}~\cite{chawla2002smote}, which is
a method for addressing the class imbalance problem. SE data
sets are often imbalanced, i.e., the data in the target class is overwhelmed by an over-abundance of information about everything else except the target~\cite{menzies2007problems}. To
address this problem, {\sma} under-samples
the majority class while intelligently super-sampling  the minority class. Standard
{\sma} is controlled by a default
set of parameters which {\smb} tunes 
for each new data set. 

To assess {\smb}, this paper explores defects from  3,681	 classes (containing over a million lines of code) from open source JAVA systems. We ask four research questions: 
 \bi\item
  \textbf{RQ1}:  {\em Are the default ``off-the-shelf'' parameters for {\sma} appropriate for
  all data sets?} 
  \ei
 \begin{lesson}{\smb} learned different parameters for each data set, all of which  were very different to default {\sma}.
 \end{lesson}
  \bi
  \item
  \textbf{RQ2}: {\em   Is  there any benefit in tuning the default parameters of {\sma} for
  each new data set?} 
  \ei
   \begin{lesson}Performance improvements using {\smb} are dramatically large, e.g., improvements in AUC up to 60\% against {\sma}.
 \end{lesson}
Some of these improvements are so very large that they overturn established wisdom in this find.
For example,  Ghotra et al.~\cite{ghotra2015revisiting} and Lessmann et al.~\cite{lessmann2008benchmarking}
 report that   random forest is a  good default choice for  defect predictors.
But with  {\smb}, random forest is usually
beaten by other classifiers. 

More generally, no learner was consistently ``best'' across all data sets and all performance criteria, yet consistently {\smb} used by  whatever  learner was found to be ``best''.  
This means,  creating better training data is more important
than the subsequent choice of a classifier.  To say that another way: ``better data'' is better than ``better data miners''.
 
% That is,  the improvements gained by
% {\smb} were  {\em  independent of the  classifier used to
% predict for defects}.
% This  result calls into question any prior ranking studies that  only considered the classifier {\em but not the data pre-processing applied before learning}.   
  
   \bi
  \item
  \textbf{RQ3}: {\em  In terms of runtimes, is the cost of running {\smb} worth the performance improvement?}
  \ei
  
   \begin{lesson}{\smb} usually terminates in under two minutes, i.e.,  fast enough
   to recommend its widespread use.
 \end{lesson}

   \bi
  \item
  \textbf{RQ4}: {\em  How does {\smb} performed against the recent class imbalance techniques?}
  \ei
  
   \begin{lesson}{\smb} performed much better than the recent technique proposed by Bennin et al.\cite{bennin2017mahakil}
 \end{lesson}
 \noindent
 Bennin et al. proposed a new method based on the chromosomal theory of inheritance. They found that {\sma} to be performing similar as their method but much better than all the other class balancing techniques in terms of Recall. But they showed their method to be performing better than {\sma} in terms of false alarm. This makes it questionable as we know from Zhang's equation~\cite{zhang2007comments} that if recall is improved then false alarm would increase too. They also did not consider the parameter tuning of any imbalanced technique, and thus we also  introduced {\smb}, providing the comparative analysis in Section \ref{sect:results}.
 
\noindent
In summary, the  contributions of this paper are:
\bi
\item The discovery of an important systematic error in  many prior ranking studies, i.e., all of
~\cite{lessmann2008benchmarking,hall2012systematic,elish2008predicting,menzies2010defect,gondra2008applying,radjenovic2013software,jiang2008techniques,wang2013using,mende2009revisiting,li2012sample,khoshgoftaar2010attribute,jiang2009variance,ghotra2015revisiting,jiang2008can,tantithamthavorn2016automated,fu2016tuning}.
\item A novel application of search-based SE ({\smb});
\item Dramatically large improvements in  defect predictors;
\item Potentially, for any other software analytics task that uses classifiers, a way to improve those learners as well;
\item A methodology for assessing the value of pre-processing data sets in software analytics;
\item A reproduction package to reproduce our results then (perhaps) to improve or refute  our results\footnote{Blinded for Review}
%\footnote{Available to download from https://github.com/ai-se/Smote\_tune},
\item A comparative analysis with other imbalanced techniques.
\ei
The rest of this paper is structured as follows:
\tion{review} gives an overview on software defect prediction.
\tion{performance} talks about all the performance criteria used in this paper.
\tion{imbalance} explains the problem of class imbalance in defect prediction. Assessment of the previous ranking studies is done in \tion{rank}.
\tion{smote} introduces {\sma} and discusses how {\sma} has been used in literature. \tion{smotuned} provides the definition of {\smb}. \tion{experiment} describes the experimental setup of this paper and above research questions are answered in
\tion{results}. Lastly, we discuss the validity of our results 
and a section describing our conclusions.
 

% \item \textbf{RQ3}: \textbf{Should SMOTE be used ``off-the-shelf'' with their default tunings?}

 

%We created a python package generalised to run any CK metrics based dataset and compare results against 6 learners. Since the classes are imbalanced we used SMOTE~\cite{chawla2002smote} (only on Training Data) which is a synthetic minority over-sampling technique.

%The remainder of the paper is organized as follows. Section \ref{review} gives a brief related work on defect prediction. Section \ref{motivation} talks about why there is a need to balance the data. Since we found astonishing results with smote, section \ref{smote} talks about SMOTE in defect prediction. Experimental setup is provided in section \ref{experiment}. Results are discussed in Section \ref{results}. Threats to validity section is discussed in section \ref{validity}. Final conclusion is being discussed in section \ref{conclusion}. And section \ref{future} talks about our future work.

 


\section{Background and Motivation}

\subsection{Defect Prediction}
\label{sect:review}

Software programming inherently introduces defects into programs, which requires to test them before they are used. Testing
is expensive and most software assessment budgets are finite while assessment effectiveness increases exponentially with assessment effort~\cite{fu2016tuning}. Exponential costs quickly exhaust resources which required to apply the best available methods on code sections
that seem most critical.

There is a long tradition in software engineering of trying to find undiscovered defects in software. 
Hall et al.~\cite{hall2012systematic} surveyed some of the methods
applied to this task: statistical approaches, capture-recapture 
(CR) models, detection profile methods (DPM)~\cite{song2011general} or
association rule mining~\cite{song2006software}. 

A variety of approaches have been proposed to recognize
 defect-prone  software components using code metrics (lines of code, complexity)~\cite{d2010extensive,menzies2007data, nagappan2006mining,shepperd2014researcher,Menzies2010}, process metrics (number of changes, recent activity)~\cite{hassan2009predicting} or previous defects~\cite{kim2007predicting}.
Other work, such as that of 
Bird et al.~\cite{bird2009putting}, indicated that it is possible to predict which components (for example modules) are likely locations of
defect occurrence using a component's development history,
and dependency structure. 
% Two key properties of software components
% in large systems are dependency relationships (which components
% depend on or are dependent on by others), and development
% history (who made changes to the components and
% how many times). Thus, we can link software components
% to other components i) in terms of their dependencies, and
% also ii) in terms of the developers that they have in common.
Prediction models based on the topological properties
of components within them have also  proven to be  
accurate~\cite{zimmermann2008predicting}.

The lesson of all the above  is that the probable location
of future defects can be guessed using   logs of past defects~\cite{hall2012systematic, catal2009systematic}. These logs might
summarize software components using
static code metrics such as 
McCabes  cyclomatic  complexity, Briands coupling metrics, code metrics,  
dependencies between  binaries, or
the  CK  metrics~\cite{chidamber1994metrics} described in  Table~\ref{fig:ck}. 
One advantage with CK metrics is that they are  simple  to  compute and hence,
they are widely used. Radjenovi{\'c} et al.~\cite{radjenovic2013software} report that in
the static code defect prediction, the CK metrics are
used  twice as much (49\%) 
as more traditional source code metrics such as McCabes (27\%) or process metrics (24\%).

But all the above methods are not effective due to either its bad accuracy of locating the defects or due to the manual task used by them. But one of the most  popular and best method is defect predictors learned from static code attributes. A software can be described with these attributes shown in Table~\ref{fig:ck}, and data miners can learn where the
probability of software defects is highest. Static code attributes can be automatically
collected, even for very large systems~\cite{nagappan2005static}. Other methods,
like manual code reviews, are far slower and far more labor intensive. 

Using these CK metrics, building static code defect predictors is remarkably fast and rapid.
Given the current generation of data mining tools, it can be a matter
of just a few seconds to learn a defect predictor (see the runtimes in Table~9 of reference~\cite{fu2016tuning}). Further, in a recent study at ICSE'14, Rahman et
al.~\cite{Rahman14} found no significant differences in the cost-effectiveness
of
(a) static code analysis tools FindBugs, and Jlint and (b) static code defect predictors.
This is an interesting result since it is  much slower to adapt static code
analyzers to new  languages than defect predictors (since the latter just requires hacking together some new
static code metrics extractors).


\subsection{Performance Criteria}
\label{sect:performance}

%\begin{figure}[!htpb]
%    \centering
%    \includegraphics[scale=0.35]{cmatrix.png}
%    \caption{Confusion Matrix}%

%    \label{fig:cmatrix}
%\end{figure}

Formally, defect prediction is a binary classification problem.
The performance of a defect predictor can be assessed via a  confusion matrix like Table~\ref{fig:cmatrix}
where a ``positive'' output is the defective class under study and a ``negative'' output is the non-defective one.
Further, ``false'' means the learner got it wrong and ``true'' means the learner correctly identified
a fault or non-fault module. Hence, Table~\ref{fig:cmatrix} has four quadrants containing, e.g., $\mathit{FP}$ which denotes ``false positive''.
\vspace{-0.2cm}

\begin{table}[!h]
\begin{center}
\caption{Confusion Matrix}
\vspace{-0.3cm}
\label{fig:cmatrix}
\begin{tabular} {@{}cc|c|c|l@{}}
\cline{3-4}
& & \multicolumn{2}{ c| }{Actual} \\ \cline{3-4}
& & defect-free & defective  \\ \cline{1-4}
\multicolumn{1}{ |c  }{\multirow{2}{*}{Prediction} } &
\multicolumn{1}{ |c| }{defect-free} & $\mathit{TN}$ & $\mathit{FN}$ & \\ \cline{2-4}
\multicolumn{1}{ |c  }{}                        &
\multicolumn{1}{ |c| }{defective} & $\mathit{FP}$& $\mathit{TP}$  &  \\ \cline{2-4}
\cline{1-4}
\end{tabular}

\end{center} 
\vspace{-0.2cm}
\end{table}


From this matrix, we can define performance measures like   \textbf{Area Under Curve (AUC)}, which 
is the area covered by an ROC curve~\cite{swets1988measuring, duda2012pattern} in which the X-axis represents, \textbf{FPR} = \mathit{FP}/(\mathit{FP} + \mathit{TN})
and the Y-axis represents, \textbf{TPR} = \mathit{TP}/(\mathit{TP} + \mathit{FN})

\noindent
\textbf{Recall} $=$ $pd$  $=$ \mathit{TP}/(\mathit{TP} + \mathit{FN}).

\noindent
 \textbf{Precision}  $=$ $prec$ $=$ \mathit{TP}/(\mathit{TP} + \mathit{FP})
 
\noindent
\textbf{False Alarm}  $=$ $pf$ $=$ \mathit{FP}/(\mathit{FP} + \mathit{TN})

As shown in Figure~\ref{fig:trade},
a typical predictor must ``trade-off''
between false alarm and recall.
This is because the  more sensitive the detector, the more often it triggers and the higher its recall. On the other hand,  if a detector triggers more often, it can also raise more false alarms.
Hence, when increasing recall, we  should  expect
the false alarm rate to  increase
(ideally, not by very much).


\begin{figure}[!b]
\begin{center}
\includegraphics[width=2.5in]{roc.png}
\end{center}
\vspace{-0.2cm}
\caption{Trade-offs false alarm vs
recall (probability of detection). Dotted line shows where false alarm is as common as detecting the signal.
The {\em negative curve} is for models where, if something is negated, performance flips  to the top-left region. }\label{fig:trade}
\end{figure}

There are many more ways to evaluate defect predictors besides the four listed above
(see Table 23.2 of~\cite{menzies2014sharing} for   eleven additional
criteria seen in the current software analytics literature).
No evaluation criteria is ``best'' since different  criteria are appropriate in different business contexts. For example, as shown
in 
Figure~\ref{fig:trade},
when dealing
with safety-critical applications, management may be
``risk adverse'' and hence many elect
 to {\em maximize recall}, regardless of the time wasted exploring  false alarm.
 Similarly, 
when rushing some non-safety critical application to market, management may be ``cost adverse''
and elect to {\em minimize false alarm} since this avoids distractions to the developers. 
 Accordingly, it is a good practice to evaluate defect predictors on more than a single performance criterion. For example, in this paper,
we use all the four   criteria listed above
(and we use four since they have
been used in recent papers  
at prominent SE conferences~\cite{ghotra2015revisiting} and SE journals~\cite{fu2016tuning}).
 

\subsection{Defect Prediction and Class Imbalance}
\label{sect:imbalance}

Class imbalance learning refers to learning from datasets that exhibit significant imbalance among or within classes. Class imbalance  is concerned with the situation in where some classes of data are
highly under-represented compared to other classes~\cite{he2009learning}.
By convention,
the under-represented class is called the {\em minority} class,
and correspondingly the class which is over-represented is called the
{\em majority} class. In this paper, we say that class imbalance is {\em worse}
when the ratio of minority class to majority {\em increases}, that is,
{\em class-imbalance of 5:95} is worse than {\em 20:80}. Menzies et al.~\cite{menzies2007problems} reported SE data sets often contain class imbalance. In their examples, they showed static code defect prediction data sets with
class imbalances of 1:7; 1:9; 1:10; 1:13; 1:16; 1:249.
They also show mathematically that  class imbalances  have a very large  negative effect on the performance of static code defect predictors.  

The problems of class imbalance are sometimes discussed in the software analytics community.
Hall et al.~\cite{hall2012systematic} found that models based on C4.5 under-perform if they have imbalanced data while Naive Bayes and Logistic regression perform relatively better. 
Their general recommendation is to not use
imbalanced data.  
Some researchers offer preliminary explorations into methods that might mitigate for class imbalance.
Wang et al.~\cite{wang2013using} and Yu et al.~\cite{yuperformance} validated the Hall et al. results and concluded that the
performance of C4.5 is unstable on imbalanced datasets while  Random Forest and Naive Bayes are 
more stable. 
Yan et al.~\cite{yan2010software} performed fuzzy logic and rules to overcome the imbalance problem, but they only
explored one kind of learner (Support Vector Machines).
Pelayo et al.~\cite{pelayo2007applying} studied the effects of the percentage of oversampling and undersampling done. They found out that different percentage of each helps improve the accuracies of decision tree learner for defect prediction using CK metrics. Menzies et al.~\cite{menzies2008implications} undersampled the non-defect class to balance training
data and reported how little information was required to learn a defect predictor. They found that throwing away data does not degrade the performance of Naive Bayes and C4.5 decision trees. Other papers show the usefulness of resampling based on different learners~\cite{pelayo2007applying, pelayo2012evaluating, riquelme2008finding}.

We note that  
many researchers in this area  (Wang, Yu et al, Gray et al.~\cite{gray2009using,yuperformance,wang2013using}) refer to the {\sma} method explored in this paper,  but only in the context of future work. 
There is one study done by Bennin et al.\cite{bennin2017mahakil} who compared many learners, with different class imbalance techniques evaluated against recall and false alarm. He selected the similar datasets which we have studied in this paper. He showed that among all the mentioned class imbalance techniques, their method and {\sma} outperform them in both the evaluation measures. Their method and {\sma} did perform same in terms of recall but their method faired on false alarm. But in this sample, no researcher has  applied auto-tuning to learn best {\sma} control parameters. We believe it to be an important factor and that is why we have provided the comparison between {\smb} and Bennin et al. method.
 

\subsection{Ranking Studies}
\label{sect:rank}

A constant problem in defect predictions is what  classifier should be applied to  build  the  defect  predictors?
To address this problem, many researchers run {\em ranking studies} where  performance scores 
are collected from  many classifiers  executed on  many software defect data sets~\cite{lessmann2008benchmarking,hall2012systematic,elish2008predicting,menzies2010defect,gondra2008applying,radjenovic2013software,jiang2008techniques,wang2013using,mende2009revisiting,li2012sample,khoshgoftaar2010attribute,jiang2009variance,ghotra2015revisiting,jiang2008can,tantithamthavorn2016automated,fu2016tuning}.
This section assesses those ranking studies. We will say a ranking study is ``good'' if it compares multiple learners using multiple data sets and multiple evaluation criteria
while at the same time doing something to address the data imbalance problem.

 In July 2017,  we searched
scholar.google.com for the conjunction of ``software'' and ``defect prediction'' and ``oo'' and ``ck'' published in the last decade. This returned 231 results.
We only selected oo and ck keywords since ck metrics are more popular and better than process metrics for software defect prediction~\cite{radjenovic2013software}.
From that list, we selected ``highly-cited'' papers, which we defined as having more than 10 citations per year. This reduced our population of papers down to 107.
After reading the titles and abstracts of those papers, and skimming the contents of the potentially interesting papers, we found 22 papers of Table~\ref{tbl:survey2} that either performed ranking studies
(as defined above) or studied the effects of class imbalance on defect prediction. In the column ``evaluated using
multiple criteria'',
papers scored more than ``1'' if they used multiple performance scores  of the kind listed at the end of \tion{performance}. 

 \begin{table}[!htbp]
\centering
\small
\caption{22 highly cited Software Defect prediction studies.}
\vspace{-0.2cm}
\label{tbl:survey2}
    \begin{tabular}{c|c|c|c|c|c}
        \begin{tabular}[c]{@{}c@{}}\textbf{ref}\end{tabular} & \textbf{Year} & \textbf{Citations} & \begin{tabular}[c]{@{}c@{}}\textbf{Ranked} \\\textbf{Classifiers?} \end{tabular} &\begin{tabular}[c]{@{}c@{}} \textbf{Evaluated} \\\textbf{using} \\\textbf{multiple} \\\textbf{criteria?}\end{tabular}&\begin{tabular}[c]{@{}c@{}} \textbf{Considered}\\\textbf{Data}\\\textbf{Imbalance?} \end{tabular}\\ \hline
        \cite{menzies2007data} & 2007 & 855 & \cmark & 2 & \xmark \\
        \cite{lessmann2008benchmarking} & 2008 & 607 & \cmark & 1 & \xmark \\ 
        %\cite{hall2012systematic} & 2012 & 413 & \cmark & 3 & \xmark \\
        \cite{elish2008predicting} & 2008 & 298 & \cmark & 2 & \xmark\\  
        \cite{menzies2010defect} & 2010 & 178 & \cmark & 3 & \xmark \\  
        \cite{gondra2008applying} & 2008 & 159 & \cmark & 1 & \xmark\\     
        \cite{Kim:2011} & 2011 & 153 &\cmark & 2 & \xmark \\ 
        \cite{radjenovic2013software} & 2013 & 150 & \cmark & 1 & \xmark \\   
        \cite{jiang2008techniques} & 2008 & 133 & \cmark & 1 & \xmark \\    
        \cite{wang2013using} & 2013 & 115 & \cmark & 1 & \cmark \\  
        \cite{mende2009revisiting} & 2009 & 92 & \cmark & 1 & \xmark \\          
        \cite{li2012sample} & 2012 & 79 & \cmark & 2 & \xmark  \\ 
        \cite{kamei2007effects} & 2007 & 73 & \xmark & 2 & \cmark\\  
        \cite{pelayo2007applying} & 2007 & 66 & \xmark & 1 & \cmark \\  
        \cite{jiang2009variance} & 2009 & 62 & \cmark & 3 & \xmark  \\ 
        \cite{khoshgoftaar2010attribute} & 2010 & 60 & \cmark & 1 & \cmark  \\  
        \cite{ghotra2015revisiting} & 2015 & 53 & \cmark & 1 & \xmark  \\  
        \cite{jiang2008can} & 2008 & 41 & \cmark & 1 & \xmark  \\  
         \cite{tantithamthavorn2016automated} & 2016 & 31 & \cmark & 1 & \xmark  \\ 
        \cite{tan2015online} & 2015 & 27 & \xmark & 2 & \cmark \\  
        \cite{pelayo2012evaluating} & 2012 & 23 & \xmark & 1 & \cmark \\  
        \cite{fu2016tuning} & 2016 & 15 & \cmark & 1 & \xmark  \\  
        \cite{bennin2017mahakil} & 2017 & 0 & \cmark & 3 & \cmark \\
\end{tabular}
\vspace{-0.3cm}
\end{table}

 \begin{table*}[!htbp]
 \caption{Classifiers used in this study.
 Rankings
 from~\cite{ghotra2015revisiting}.}
 \vspace{-0.2cm}
 \label{tbl:learners}
 \small
 \begin{tabular}{l|l|p{4.5in}}
{\bf RANK} & {\bf LEARNER} & {\bf NOTES}\\\hline
 1 ``best'' & RF= random forest & 
 Random forest of entropy-based decision trees.\\\cline{2-3}
 &  LR=Logistic regression &
 A generalized linear regression
model.\\\hline
 2 & KNN= K-means &  Classify a new instance by finding ``k'' examples of similar instances.
 Ghortra et al suggested
 $K=8$.\\\cline{2-3}
 & NB= Naive Bayes &  Classify a new instance by (a)~collecting mean and standard deviations of attributes in old instances of  different classes; (b)~return the class whose attributes are statistically most similar to the new instance.\\\hline
 3 & DT= decision trees & Recursively
 divide data by selecting attribute splits
 that reduce the entropy of the class distribution.\\\hline

 4 ``worst'' & SVM= support vector machines &
 Map the raw data into a higher-dimensional space where it is easier to distinguish the examples.
 \\\hline
 \end{tabular}
 \end{table*}

We find that, in those 22 papers,
numerous classifiers have used AUC software defect
predictor ranking studies.  
As
 noted in~\cite{lessmann2008benchmarking, ghotra2015revisiting},  no single classification technique always dominates.  
 That said, Table~IX of a recent study by Ghotra et al.~\cite{ghotra2015revisiting}
 ranks numerous classifiers  using data similar
 to what we use here (i.e., OO JAVA systems described using CK metrics).
 Using their work, we can select
 a range of classifiers  for this study
 ranking from ``best''
 to ``worst': see Table~\ref{tbl:learners}.
 
 \begin{wrapfigure}{r}{1.8in}
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=1.8in]{venn.png}
  \caption{Summary of papers from Table~\ref{tbl:survey2}.}
\label{fig:s2}
\end{wrapfigure}

%  \begin{figure}[!htbp]
% \begin{center}
% \includegraphics[width=2.5in]{venn.png}
% \end{center}
% \caption{Summary of papers from Table~\ref{tbl:survey2}.}
% \label{fig:s2}
% \end{figure}
 
%\renewcommand\arraystretch{1.2}

% Accordingly, this paper is a ranking study that (a)~uses   multiple performance criteria to assess its classifiers; while (b)~fixing regions of the training
%  data with a weak signal  via synthetic data generation (using {\smb}, which is a self-tuning variant of {\sma}~\cite{chawla2002smote}). {\sma} is controlled by parameters which are normally set via ``expert judgement'' (a.k.a. guessing).
%  {\smb} uses a search-based SE technique called DE {\em differential evolution}~\cite{storn1997differential}) to automatically learn the best parameters for each data set. For more on {\smb}, see the next section.

% There are many studies done to find the best defect prediction performing model. Before 2007, it can be observed that almost every defect prediction study worked with 1 or 2 classification techniques evaluate on 1 or 2 measures. And almost none of the studies consider the effects of data imbalance. From Table~\ref{tbl:survey2} there has been ranking studies to find the best performing classifiers in about 16 out of 21 studies. Out of these 16, only 3 studied the effects of imbalance and among these 3 none studied for multiple evaluation goals.
% We highly agree to this given so many variations available in the data band there are so many classification techniques available like 

The key observation to be made from  this 
survey is that, as shown in Figure~\ref{fig:s2}, only 1 prior study in our sample satisfied  our definition of a ``good'' (see the ``1'' in the middle of the Venn diagram) project~\cite{bennin2017mahakil}. 
Accordingly, the rest of this
paper defines and executes a ``good'' ranking  study. A unique feature of our
ranking study is the use of an auto-tuning version of SMOTE.

\subsection{Handling Data Imbalance with SMOTE}
\label{sect:smote}

SMOTE handles class imbalance by changing the frequency of different classes of the training
data~\cite{chawla2002smote}. 
The algorithm's name is short for ``synthetic minority over-sampling technique''.
When applied to data, SMOTE sub-samples the majority class (i.e., deletes some examples)
while super-sampling the minority class
until
all classes have the same frequency.  In the case of software defect data,
the minority class is usually the  defective class.



Figure~\ref{fig:pseudocode} shows how SMOTE works. During super-sampling,
a member of the minority class finds $k$ nearest neighbors. It builds a fake member
of the minority class at some point in-between itself and one of its nearest
neighbors.  During that process, some distance function is required which is the {\em minkowski\_distance} function. 

\noindent
Note that SMOTE is controlled by these  parameters:
\bi
\item $k$ controls how many neighbors to use during over-sampling. Defaults to $k=5$.
\item $m$ is how many examples of each class are generated. Defaults to $m=50\%$ of the total training samples.
\item $r$ controls the distance function. The default is $r=2$,
i.e., use the  
standard Euclidean distance metric.
\vspace{-0.3cm}
\ei

 \begin{figure}[!h]
\begin{lstlisting}[mathescape,linewidth=8.0cm,frame=r,numbers=right]
  def SMOTE(k=2, m=50%, r=2):  # default settings
    while Majority > m do
      delete any majority item
    while Minority < m do
      add something_like(any minority item)
      
  def something_like(X0): 
    relevant = emptySet
    k1 = 0
    while(k1++ < 20 and size(found) < k)  {
       all = k1 nearest neighbors
       relevant += members of "all" of same class as X0 }
    Z = any of found
    Y = interpolate (X0, Z)
    return Y
    
  def minkowski_distance(a,b,r): 
    return $( \Sigma_i\ abs(a_i - b_i)^r)^{1/r}$
\end{lstlisting}
\vspace{-0.3cm}
\caption{Pseudocode of SMOTE}
\label{fig:pseudocode}  
\vspace{-0.3cm}
\end{figure}

% Different data preprocessing has been proved
% to improve the performance of defect prediction models by
% Menzies et al.~\cite{menzies2007data}. Jiang et al.~\cite{jiang2008can} evaluate the impact of
% log transformation and discretization on the performance
% of defect prediction models, and report different modeling
% techniques ``prefer'' different transformation techniques. For
% instance, Naive Bayes achieves better performance on discretized
% data, while logistic regression achieves better performance
% for both. Peters et al.~\cite{peters2013better} propose different filters; and Li et al.~\cite{li2012sample} propose
% to use sampling. Nam et al.~\cite{nam2013transfer} transformed both
% training and testing data to the same latent feature space,
% and build models on the latent feature space. 
% %Too many variables in the datacan result in the ``curse of dimensionality''~\cite{friedman1997bias}.
% Feature Selection is a common method that can
% reduce features and sampling can balance the diversity of
% class instance numbers~\cite{yin2015empirical}, in turn improving the performance of defect prediction. In this paper we only tackle the class imbalance problem.


In the software analytics literature, there are contradictory findings on
the value of applying SMOTE for software defect prediction.
Van et al.~\cite{van2007experimental}, Pears et al.~\cite{pears2014synthetic} and Tan et al.~\cite{tan2015online} found SMOTE to be advantageous, while others, such as Pelayo et al.~\cite{pelayo2007applying} did not. 

Further, some researchers report that some learners respond better than others to standard SMOTE. Kamei et al.~\cite{kamei2007effects} evaluated the effects of SMOTE applied to  four fault-proneness models
(linear discriminant analysis, logistic regression, neural network and classification tree) by
using two module sets of industry legacy software. They reported that SMOTE improved the prediction performance of the linear and logistic models, but not neural network and classification tree models. Similar results, that the value of SMOTE was dependent on the learner,
was also reported by Van et al.~\cite{van2007experimental}.

\subsection{SMOTUNED = auto-tuning SMOTE}
\label{sect:smotuned}

One possible explanation for the variability in the {\sma} results is that the
default parameters of this algorithm are not suited to all data sets. To test this,
we designed {\smb}, which is an auto-tuning version of {\sma}. {\smb}
uses different control parameters for different data sets.


 
{\smb} uses DE (differential evolution~\cite{storn1997differential}) to explore the parameter space of
Table~\ref{tb:tuned}.  DE is an
optimizer useful for functions that may not be smooth or linear.  Vesterstrom et al.~\cite{Vesterstrom04} find   DE's optimizations to be  competitive with other optimizers like 
   particle swarm optimization or genetic algorithms.
   DEs have been used before for   parameter tuning~\cite{omran2005differential, chiha2012tuning,fu2016tuning,fu2017easy, agrawal2016wrong}) but this paper is  the first attempt to do
   DE-based class re-balancing.

\begin{figure}[!b]
\begin{lstlisting}[mathescape,linewidth=8.2cm,frame=r,numbers=right]
  def DE( n=10, cf=0.3, f=0.7):  # default settings
    frontier = sets of guesses (n=10)
    best = frontier.1 # any value at all
    lives = 1
    while(lives$--$ > 0): 
      tmp = empty
      for i = 1 to $|$frontier$|$: # size of frontier
         old = frontier$_i$
         x,y,z = any three from frontier, picked at random
         new= copy(old)  
         for j = 1 to $|$new$|$: # for all attributes
           if rand() < cf    # at probability cf...
              new.j = $x.j + f*(z.j - y.j)$  # ...change item j
         # end for
         new  = new if better(new,old) else old
         tmp$_i$ = new 
         if better(new,best) then
            best = new
            lives++ # enable one more generation
         end                  
      # end for
      lives--
      frontier = tmp
    # end while
    return best
\end{lstlisting}
\caption{SMOTUNED uses DE (differential evolution).}
\label{fig:pseudo_DE} 
\end{figure}


In Figure~\ref{fig:pseudo_DE}, DE evolves a \textit{frontier} of
candidates from an initial population which is driven by a goal (like maximizing recall) evaluated using a fitness function (shown in line 17). In the case of {\smb},
each  candidate is a randomly selected value for SMOTE's $k, m$ and $r$ parameters.
 To evolve the frontier, within each generation,
 DE compares each item to a {\em new} candidate generated
 by combining three other frontier items (and better {\em new} candidates replace
 older items). 
 To compare them, the {\em better} function (line 17) calls $SMOTE$ function using the proposed {\em new} parameter settings shown in Figure \ref{fig:pseudocode}. This pre-processed training data is then fed into a classifier to find a particular measure (like recall).
 When our DE  terminates, it returns the best candidate ever seen in the entire run.
 
Table~\ref{tb:algo2} provides an overview of LDADE algorithm. While tuning, {\smb} explores 
the parameter ranges shown  in  Table~\ref{tb:tuned}. To define
the parameters, we found the range of used settings for {\sma} and distance functions
in the   SE and machine learning  literature.  Aggarawal et al.~\cite{aggarwal2001surprising}
argue that with data being highly dimensional, $r$ should shrink to some fraction less than one
(hence the bound of $r=0.1$ in Table~\ref{tb:tuned}. 

\begin{table}[!t]
    \begin{center}
    \small
\caption{List of parameters tuned by this paper}
\vspace{-0.2cm}
\label{tb:tuned}
 \begin{tabular}{p{0.5cm}|c@{~}|c@{~}|p{3.3cm}}
         \textbf{Para} &  \begin{tabular}[c]{@{}c@{}}\textbf{Defaults} \\ \textbf{used by} \\\textbf{SMOTE} \end{tabular}
          &  \begin{tabular}[c]{@{}c@{}}
          \textbf{Tuning Range} \\
           \textbf{(Explored by} \\ \textbf{( SMOTUNED)} \end{tabular}&  \textbf{Description} \\
        \hline
        $k$ & 5 & [1,20] & Number of neighbors \\ 
        \hline
       $m$ & 50\% & {50, 100, 200, 400} & Number of synthetic examples to create. Expressed as a percent  of final training data. \\ 
        \hline
        $r$ & 2 & [0.1,5] & Power parameter for the Minkowski distance metric.\\
 
\end{tabular}
\end{center}
\end{table}

\begin{table}[!htbp]
\begin{center}
\small
\caption{Overview of Algorithm SMOTUNED}
\vspace{-0.3cm}
\label{tb:algo2}
\begin{tabular}{|c@{~}|p{4.0cm}|}
        \hline 
        \textbf{Keywords} & \textbf{Description}\\
        \hline

        \begin{tabular}[c]{@{}c@{}}Differential weight $(f=0.7)$\end{tabular} & Mutation power\\
        \hline
        \begin{tabular}[c]{@{}c@{}}Crossover probability $(cf=0.3)$\end{tabular} & Survival of the candidate\\
        \hline
        \begin{tabular}[c]{@{}c@{}}Population Size $(n=10)$\end{tabular} &  Frontier size in a generation \\
        \hline
        \begin{tabular}[c]{@{}c@{}}Lives\end{tabular} & Number of generations\\
        \hline
        \begin{tabular}[c]{@{}c@{}}Fitness Function $(better)$\end{tabular} & Driving factor of DE\\
        \hline
        \begin{tabular}[c]{@{}c@{}}Rand() function\end{tabular} & Returns between 0 to 1 \\
        \hline
        \begin{tabular}[c]{@{}c@{}}Best (or Output)\end{tabular} & Optimal configuration for SMOTE \\
        \hline
\end{tabular}
\end{center}
\end{table}

\vspace{-0.6cm}
\section{Experimental Design}
\label{sect:experiment}
 
This experiment  reports the effects of altering defect prediction
training
data   via {\smb} or {\sma} or not at all. 
 
 \begin{table}[!t]
\begin{center}
\small
\caption{Dataset statistics. Datasets are sorted from low percentage of defective class to high defective class.
Data comes from the SEACRAFT repository: http://tiny.cc/seacraft}.
\vspace{-0.2cm}
\label{tb:dataset}

\begin{tabular}{r@{~}|r@{~}|r@{~}|r@{~}|r@{~}|r@{~}}
        \begin{tabular}[c]{@{}c@{}}\textbf{Version}\end{tabular} & \begin{tabular}[c]{@{}c@{}} \textbf{Dataset} \\ \textbf{Name}\end{tabular} & \textbf{Defect \%} & \textbf{Non-Defect \%} &\begin{tabular}[c]{@{}c@{}} \textbf{No. of} \\ \textbf{classes}\end{tabular}&\begin{tabular}[c]{@{}c@{}} \textbf{lines of} \\ \textbf{code} \end{tabular}\\ \hline
4.3 & jEdit & 2 & 98 & 492 & 202,363 \\ 
1.0 &   Camel & 4 & 96 & 339 & 33,721 \\  
6.0.3 &   Tomcat & 9 & 91 & 858 & 300,674\\ 
2.0 &   Ivy & 11 & 89 & 352 & 87,769 \\  
1.0 & Arcilook & 11.5 & 88.5 & 234 & 31,342\\ 
1.0 & Redaktor & 15 & 85 & 176 & 59,280 \\ 
1.7 & Apache Ant & 22 & 78 & 745 & 208,653 \\  
1.2 &   Synapse & 33.5 & 66.5 & 256 & 53,500 \\ 
1.6.1 &   Velocity & 34 & 66 & 229 & 57,012 \\\hline
  \multicolumn{4}{r|}{ total:} &    3,681&	1,034,314\\ 

\end{tabular}
\end{center}
\vspace{-0.4cm}
\end{table}


\newcommand\fnote[1]{\captionsetup{font=small}\caption*{#1}}

\begin{figure*}[!b]
    \centering
    \begin{minipage}{.33\textwidth}
    \centering
    \includegraphics[width=.95\linewidth]{./fig/k.png}
        {\bf Figure~\ref{fig:para}a:} Tuned values for $k$\\ (default:  $k=5$).
    \end{minipage}~~%
    \begin{minipage}{.33\textwidth}
    \centering
        \includegraphics[width=.95\linewidth]{./fig/m.png}
        {\bf Figure~\ref{fig:para}b:} Tuned values for $m$\\ (default: $m=50\%$).
    \end{minipage}~~%
    \begin{minipage}{.33\textwidth}
    \centering
        \includegraphics[width=.95\linewidth]{./fig/r.png}
        {\bf Figure~\ref{fig:para}c:} Tuned values for $r$\\ (default:  $r=2$).
    \end{minipage}
    \vspace{-0.2cm}
    \caption{Datasets vs Parameter Variation when optimized for recall and results reported on recall.
    ``Median'' denotes 50th percentile values seen in the 5*5 cross-validations and ``IQR'' shows the intra-quartile
    range, i.e., (75-25)th percentiles.}
    \label{fig:para}
\end{figure*}


Before proceeding 
we   stress the following methodological
principle.
To test the efficacy of any learner, it is important to
use test data whose class distributions match the real-world distributions.
Hence {\sma} (and {\smb}) should only
be applied to the training data {\em but
not to the test data}.



\subsection{Top-Level Loop}


Using some data $D_i \in D$, performance measure $M_i \in M$, and classifier $C_i \in C$,
this experiment conducts the 5*5 cross-validation study, defined below.
Our datasets  $D$ are shown in  Table~\ref{tb:dataset}. These are all open source
JAVA OO systems described in terms of the CK metrics described. 
Since, we are comparing these results for imbalance class, only imbalanced class datasets are selected from Seacraft\footnote{http://tiny.cc/seacraft}.

Our performance measures $M$ were introduced in \tion{performance}
which includes   AUC, precision, recall, and the  false alarm. 
Our classifiers
 $C$  come from a  recent ICSE paper~\cite{ghotra2015revisiting}
and were listed in  Table~\ref{tbl:learners}.
For  implementations 
of these learners,
we used  the open source tool
Scikit-Learn~\cite{pedregosa2011scikit}.
Our  cross-validation study~\cite{refaeilzadeh2009cross} was defined as follows:
\be
\item We randomized the order of the data set $D_i$ set five times. This reduces the probability
that some random ordering of examples in the data will conflate our results.
\item Each time, we divided the data $D_i$ into five bins;
\item For each bin (the test), we trained on four bins (the rest) and then tested
on the test bin as follows:
\be
\item
Important point: {\em we only {\sma} the training data,  leaving
the  testing data unchanged}.
\item
The  training set is pre-filtered using either No-SMOTE (i.e., do nothing) or  {\sma} or {\smb}.  
\item
When using {\smb}, we further divide those four bins of training data. 3 bins are used for training the model, and 1 bin is used for validation in DE. DE is  run to  improve
the performance measure $M_i$ seen when the classifier $C_i$ was applied to the training data.
Important note: {\em when tuning {\sma}, this rig \underline{{\em never}} uses test data}.
\item
After pre-filtering, a classifier $C_i$  learns a predictor.
\item
The model is applied to the test data to collect performance measure $M_i$. 
\item 
We print the {\em performance delta} between this $M_i$ and another  $M_i$
generated from applying $C_i$ to the raw data $D_i$ (i.e., compared to learning
without any filtering).
\ee
\ee


   
   
Note that the above rig tunes {\sma}, but not the control parameters of the classifiers.
We do this since, in this paper,  we aim to document the   benefits of tuning {\sma} since as shown below, they are very large indeed. Also, it would be very useful if we can show that a single algorithm ({\smb})  improves the performance of defect prediction. This would allow
subsequent work to focus on the task of optimizing  {\smb} (which would be a far easier
task than optimizing the tuning of a wide-range of classifiers). 
 

\subsection{Within- vs Cross-Measure Assessment}
\label{sect:wcm}

We call the above rig as the {\em within-measure assessment rig} since it is  biased in its evaluation measures. Specifically,  in this rig,
when {\smb} is optimized for (e.g.) AUC, we do not explore the effects on (e.g.) the false alarm. This is less than ideal
since it is known that our performance measures are inter-connected via the Zhang equation~\cite{zhang2007comments}. Hence, increasing (e.g.) recall might potentially have the adverse
effect of  driving up (e.g) the false alarm rate. 
To avoid this problem, we also apply the following {\em cross-measure assessment rig}.
At the conclusion of the {\em within-measure assessment rig}, we will observe  that the AUC performance measure will show the largest improvements. Using that best performer, we will re-apply steps 1,2,3 abcdef (listed above) but this time:
\bi
\item In step 3c, we will tell {\smb} to optimize for AUC;
\item In step 3e, 3f we will collect the performance delta on AUC as well as precision, recall,
and false alarm.
\ei
In this approach, steps 3e and 3f collect the information required   to check if succeeding according to one performance criteria results in damage to another. We would also want to make sure that our model is not over-fitted based on 1 evaluation measure. And since {\smb} is a time expensive task, we do not want to tune for each measure which will quadruple the time. The results of within- vs cross-measure assessment is shown in Section \ref{sect:results}.


\subsection{Statistical Analysis}

When comparing the results of {\smb} to other
treatments, we use a statistical
significance test and an effect size test.
Significance test are usefully for detecting if two populations
differ merely by random noise. 
Also, effect sizes are useful for checking that two populations differ by more than just a trivial amount.

For the significance test,  we use the 
     Scott-Knott procedure  recommended  recently in TSE'13~\cite{mittas13} and at ICSE'15~\cite{ghotra2015revisiting}. This
     technique recursively bi-clusters a sorted
    set of numbers. If any two clusters are statistically indistinguishable, Scott-Knott
    reports them both as one group.
    Scott-Knott first looks for a break in the sequence that maximizes the expected
    values in the difference in the means before and after the break.
    More specifically,  it  splits $l$ values into sub-lists $m$ and $n$ in order to maximize the expected value of differences  in the observed performances before and after divisions. For e.g., lists $l,m$ and $n$ of size $ls,ms$ and $ns$ where $l=m\cup n$, Scott-Knott divides the sequence at the break that maximizes:
     \[E(\Delta)=ms/ls*abs(m.\mu - l.\mu)^2 + ns/ls*abs(n.\mu - l.\mu)^2\]
Scott-Knott then applies some statistical hypothesis test $H$ to check if $m$ and $n$ are significantly different. If so, Scott-Knott then recurses on each division.
    For this study, our hypothesis test $H$ was a conjunction of the A12 effect size test (endorsed by
    \cite{arcuri11})  and non-parametric bootstrap sampling \cite{efron94}, i.e., our Scott-Knott divided the data if {\em both}
    bootstrapping and an effect size test agreed that the division was statistically significant (99\% confidence) and not a ``small'' effect ($A12 \ge 0.6$).
   

\begin{figure*}[!t]
\begin{minipage}{.5\linewidth}
\centering
        \includegraphics[width=.95\linewidth,height=6.5cm]{./fig/AUC_recall_tuned.png}
    \end{minipage}%
\begin{minipage}{.5\linewidth}
        \centering
        \includegraphics[width=.95\linewidth,height=6.5cm]{./fig/prec_pf_tuned.png}
    \end{minipage}%
    
    \caption{SMOTUNED improvement over SMOTE. \underline{Within}-Measure
    assessment (i.e., for each of these charts,
    optimize for performance measure $M_i$, then test for
    performance measure $M_i$). For most charts
    {\em larger} values are {\em better}, but for false alarm,
    {\em smaller} values are {\em better}. Note that the corresponding percentage of minority class (in this case, defective class) is written beside each dataset.}
    \label{fig:tuned}
\end{figure*}

\begin{figure*}[!t]
\begin{minipage}{.49\linewidth}
\centering
        \includegraphics[width=0.9\linewidth,height=4.5cm ]{./fig/AUC_recall.png}
            \end{minipage}%
\begin{minipage}{.49\linewidth}
        \centering
        \includegraphics[width=0.9\linewidth,height=4.5cm]{./fig/prec_pf.png}
    \end{minipage}%
    \caption{Scott Knott analysis of No-SMOTE, SMOTE and SMOTUNED. The column headers are denoted as No for No-SMOTE, S1 for SMOTE and S2 for SMOTUNED. $(\ast)$ Mark represents the best learner combined with its techniques. Difference in within- vs cross-measure is explained in Section~\ref{sect:wcm}}
    \label{fig:stats}
\end{figure*}

\section{Results}
\label{sect:results}

\bi
 \item {\bf RQ1: Are the default ``off-the-shelf'' parameters for SMOTE appropriate for all
 data sets?}
 \ei
 
 As discussed above, the default parameters for
 {\sma} are $k,\ m$ and $r = 5,\ 50\%$ and $2$.
  Figure~\ref{fig:para} shows the range of parameters
 found by {\smb} across  nine data sets for the 25 repeats of our cross-validation procedure.
 All the results in this figure are {\em within-measure assessment} results, i.e.,
 here, we {\smb}  on a particular performance measure and then we only collect performance for that performance measure on the test set.
 
 
 In  Figure~\ref{fig:para}, the {\em median} is the 50th percentile
 value and {\em IQR} is the (75-25)th percentile
 (IQR is a non-parametric analogue of variance).
 As can be seen in Figure~\ref{fig:para}, most of the learned parameter are far from the default values:
 \bi
 \item 
 Median $k$ value was never less than 11;
 \item
 Median $m$ value differs according to each dataset and quite far from the actual;
 \item
 The $r$ value used in the distance function was never 2. Rather, it was usually 3.
 \ei
 Hence,  our answer to {\bf RQ1} is ``no'': the use of off-the-shelf {\sma} should be deprecated. 
 
 Before moving on to {\bf RQ2}, we note that many of the settings in Figure~\ref{fig:para} are very similar; for example, median values of $k=13$ and $r=3$ seems to be a common
result.  Nevertheless, we do {\em not} recommend replacing
the defaults on regular {\sma} with the median values
of Figure~\ref{fig:para}. In that figure, many of the  IQR bars are
very large (IQR=intra-quartile range = denotes the
75th-25th percentile). Clearly, SMOTUNED's decisions vary dramatically
depending on what data  is being processed.  Accordingly,
we strongly recommend that {\smb} be applied to each new data set.

\begin{figure}[!t]
  \centering
\includegraphics[width=\linewidth,height=6cm,keepaspectratio]{./fig/runtimes.png}
  \caption{Datasets vs Runtimes. Note that the numbers
  shown here are the mean times seen across 25 repeats of a 5*5 cross-validation study.
  %running six learners through a 5*5 cross-validation. Hence, for mean
  %runtimes for one learner, {\em divide} these numbers by 6*5*5=150.
  }
  \label{runtime}
\end{figure}

\bi
\item {\bf RQ2: Is there any benefit in tuning the default parameters of SMOTE for each new data set?}
\ei

Figure~\ref{fig:tuned} shows the performance delta of the {\em within-measure assessment rig}.
Please recall that when this rig applies {\smb}, it optimizes for performance measure, $M_i \in \{recall,\ precision,\ false$ $\ alarm,\ AUC\}$
after which it uses the {\em same} performance measure
$M_i$ when evaluating the test data. In Figure~\ref{fig:tuned}, each subfigure shows that DE is optimized for each $M\_i$ and results are reported against the same $M\_i$.
From the figure~\ref{fig:tuned}, it is observed that
{\smb} achieves large AUC (about 60\%) and recall (about 20\%) improvements
without
 damaging precision and  with only minimal changes
 to false alarm. A special note should be taken of the AUC improvements- these are the largest improvements
 we have yet seen, for any prior treatment of defect prediction data.

Figure~\ref{fig:stats} offers a statistical analysis
of different results achieved
after applying our three data pre-filtering methods: 1) {\em \textbf{NO}} = do nothing, 2) {\em \textbf{S1}} = use default {\sma}, and 3) {\em \textbf{S2}} = use {\smb}.
For any learner, there are three such treatments and {\em darker} the cell, {\em better} the performance. 
In that figure, cells with the same color are
either not statistically significantly different or
are different only via a {\em small effect}
(as judged by the statistical methods described above).

As to what combination of pre-filter+learner works better for any data set, that is marked by a ``*''. Since we have three pre-filtering methods and six learners, there is one   ``*'' per 18 cells in Figure~\ref{fig:stats}.

In the  AUC and recall results,  the best ``*'' cell always appears in the S2={\smb} column. 
That is, for those two performance measures,  {\smb} is always
used by the best combination of pre-filter+learner .

As to precision  results,  at first glance, the  results in Figure~\ref{fig:stats} look bad for {\smb} since, less than half the times, 
the best ``*''  happens  in S2={\smb} column.
 But recall from Figure~\ref{fig:tuned} that the absolute size of the precision deltas is very small.  Hence, even though {\smb} ``losses'' in this statistical analysis, the pragmatic impact of that result  is  negligible.
 
As to the false alarm results of Figure~\ref{fig:stats}, as discussed above in \tion{performance}, the cost of increased recall is to also increase
the false alarm rate. For example, the greatest \textit{increase} in recall was 0.58 seen in the {\em jEdit} results. This increase comes at a cost
of \textit{increasing} the false alarm rate by 0.20. Apart from this one large outlier, the overall pattern is that the recall improvements range from +0.18 to +0.42 (median to max)
and these come at the cost of much smaller false alarm \textit{increase} of 0.07 to 0.16 (median to max). 
 
In summary, the answer to {\bf RQ2} is that our  AUC and recall results strongly endorse the  use of {\smb}
while the precision and false alarm rates
show there is little harm in using {\smb}.

Before moving to the next research question, we note that these
 results offer an interesting insight on prior ranking studies that rank some learners
as ``better'' than another.
Recall from Table~\ref{tbl:learners} that prior studies have offered an approximate ranking for different learners; specifically: $
(\mathit{RF},\mathit{LR}) > (\mathit{KNN},\mathit{NB}) > (\mathit{DT}) > (\mathit{SVM})$

If we count how often our learners perform
best in the AUC and recall results of Figure~\ref{fig:stats} (i.e., how many times they were marked with ``*'') then, at first
glance, it would seem that Figure~\ref{fig:stats} is recommending very nearly the same
learners as ``best'' for defect prediction as   Table~\ref{tbl:learners}: $\begin{array}{c}
(\mathit{RF}=7) > (\mathit{LR}=5) > (\mathit{KNN}=4) >\\
(\mathit{SVM}=2) > (\mathit{NB}=0, \mathit{DT}=0)
\end{array}$

Here, we do not count  the precision and false alarm counts since, as discussed above, the size
of that delta is so small (particularly when compared to the AUC+recall effects).

\begin{figure*}[!t]
\begin{minipage}{.5\linewidth}
\centering
        \includegraphics[width=.95\linewidth,height=6.5cm]{./fig/AUC_auc1.png}
    \end{minipage}%
\begin{minipage}{.5\linewidth}
        \centering
        \includegraphics[width=.95\linewidth,height=6.5cm]{./fig/AUC_prec.png}
    \end{minipage}%
    
    \caption{ SMOTUNED improvement over SMOTE. 
    \underline{{\bf Cross}}-Measure
    assessment (i.e., for each of these charts,
    optimize for \underline{{\bf AUC}}, then test for
    performance measure $M_i$).  Same format as
    Figure~\ref{fig:tuned}.}
    \label{fig:auc22}
\end{figure*} 

The key point here is that there are 18 experiments in the left-hand-side of Figure~\ref{fig:stats}. That is,
even though RF (random forests) has the highest  ``best'' scores, it still defeated in \mbox{$(18-7)/18=61\%$}
experiments. This means that we must doubt the conclusions of prior ranking studies like 
 Table~\ref{tbl:learners} since we find that no   learner was  consistently  ``best''  across most of our experiments.
On the other hand, 
  {\smb} was  consistently  used  by  whatever  learner  was  found  to  be ``best'' (in recall and AUC). 
Hence, we conclude from the {\b RQ2} results that  prior ranking study results (that only assessed different learners) have missed a much more general effect about the benefits of data pre-processing.
To say that another way, ``better data'' might be better than ``better data miners''.

As a last note about the {\bf RQ2} results, we note that they offer a new insight into
the true value of methods of {\sma}.
When we drew the plots of  Figure~\ref{fig:tuned}, we deliberately ordered
the x-axis data sets according to their imbalance, 1) The data sets with the {\em highest} ratio of defects (Velocity and Synapse) are shown on the left-hand side of each plot in Figure~\ref{fig:tuned}, and 2) While the data sets with the {\em lowest} ratio of defects (jEdit and Camel) are shown on the right-hand side.

Given that ordering of the x-axis, repairing class imbalance should improve the performance as we move from left to right hand side of the  Figure~\ref{fig:tuned} plots.
But this is not the case (and effect size tests confirm that visual impression).
Hence, we conjecture that the   real value of {\sma} (and {\smb}) is not fixing the class imbalance, rather, SMOTE's
value might be in {\em amplifying} the data's signal in sparse regions of the data (by filling
in those regions with synthetic examples extrapolated from the local region). 

\bi
\item {\bf RQ3: In  terms  of  runtimes,  is  the  cost  of  running  {\smb} worth the performance improvement?}
\ei

Figure \ref{runtime} shows the mean runtimes
for running a 5*5 cross-validation study for six learners for each data set.
These runtimes were collected from one machine running CENTOS7, with 16 cores.
Note that they do not increase monotonically with the size of the data sets since:
\bi
\item Our version of {\sma} uses ball trees to optimize the nearest neighbor calculations. Hence, the runtime of that algorithm is dominated by the internal topology of the data sets rather than the number of classes.
\item
As shown in 
Figure~\ref{fig:pseudocode} (lines 9-12),
{\smb} explores the local space until it finds $k$ neighbors of the same class. This can take a variable amount of time to terminate.
\ei
As expected,  {\smb} is an order of magnitude slower than {\sma} since
it has to run {\sma} many times to assess different parameter settings.
That said, those runtimes are not excessively slow.
{\smb} usual terminates in under two minutes and never more than half an hour.
% Figure~\ref{runtime} by 5*5*6=150, we see that even for our slowest data sets (tomcat), one run
% of SMOTUNED terminated in 34284/150=228 seconds (on an average), which is less than four minutes.
Hence, in  our opinion, we answer {\bf RQ3} as ``yes'' since the   performance increases
seen in Figure~\ref{fig:tuned} more than compensate for the extra CPU required for {\smb}.

\bi
\item{\bf RQ4: How does {\smb} performed against the recent class imbalance techniques?}
\ei

The most recent technique introduced by Benning et al~\cite{bennin2017mahakil} is Mahakil which is based on chromosomal theory of inheritance. A reproduction package was not available, so, we tried replicating their algorithm and the settings (a replication package is now provided\footnote{Blinded for Review}).
%\footnote{Available to download from https://github.com/ai-se/MAHAKIL_imbalance},
Their study reported that {\sma} performed better than all other previous imbalance techniques (techniques reported by Bennin et al.) for recall and false alarm and produced similar results against Mahakil for recall measure. But Mahakil was reported to perform better than {\sma} in terms of false alarm.

We find this to be highly unlikely as we know from Zhang's equation~\cite{zhang2007comments} that if recall is increased then false alarm would also increase. The other important factor, find to be missing was an automated method of tuning the parameters of an imbalance technique and thus we introduced {\smb} and compared the 2 methods.

To show the increase in recall would also result in false alarm, we compared the Mahakil results against the {\sma}. As shown in figure (available from https://ibb.co/gC7Vu5), we observed that we are seeing about 30\% improvement on {\sma} over Mahakil. But this also resulted in the increment of false alarm, which is not desired. But we see Mahakil wins over {\sma} in terms of AUC in most cases.

For the comparative analysis of {\smb} and Mahakil, please look at the results which is available from http://ibb.co/iwKw1k. We observed that we are getting consistent improvement on {\smb} of about 30\% than Mahakil, and {\smb} also resulted in improved performance in terms of AUC.

\section{Threats to Validity}
\label{sect:validity}

As with any empirical study, biases can affect the final
results. Therefore, any conclusions made from this work must consider the following issues in mind.

\textbf{\textit{Order bias}}: With each dataset how data samples are distributed in training and testing set is completely random. Though there could be times when all good samples are binned into training and testing set. To mitigate this order bias, we run
the experiment 25 times by randomly changing the order of the data samples each time.

\textbf{\textit{Sampling bias}} threatens any classification experiment, i.e., what matters there may not be true here. For example, the datasets used here comes from the SEACRAFT repository and were supplied by one individual. These datasets have used in various case studies by various researchers~\cite{he2012investigation,peters2013better,peters2013balancing,turhan2013empirical}, i.e., our results are not more biased that many other studies in this arena.
That said, our nine open-source datasets   are mostly from Apache. Hence
it is an open issue if our results hold for
 proprietary projects and open source projects from other sources.

% \textbf{\textit{Learner bias}}: For building the defect predictors in this
% study, we selected each learner with default parameters like k=8 in $k$-NN, entropy as split criteria in RF, and DT. The above predefined parameters have been used in the conclusions made by other studies~\cite{ghotra2015revisiting,tantithamthavorn2016automated}. 

\textbf{\textit{Evaluation bias}}: In terms of evaluation bias,
our study is far less biased than many other ranking studies.  As shown by our sample of
22 ranking studies in
Table~\ref{tbl:survey2}, 19/22 of those prior studies used {\em fewer} evaluation criteria
than the four reported here (AUC, recall, precision and false alarm). 

The analysis done in RQ4 could be affected by some other settings which we have not considered since the reproduction package was not available from the original paper~\cite{bennin2017mahakil}.
That said, there is another more subtle evaluation bias in  Figure~\ref{fig:tuned}. Note that the four plots of that figure are four {\em different} runs of our  {\em within-measure assessment rig}
(defined in \tion{wcm}). Hence, it is reasonable to check what happens when (a)~one
evaluation criteria is used to control {\smb}, and (b)~the results are assessed
using all four evaluation criteria. 
Figure~\ref{fig:auc22} shows the results of such a {\em cross-measure assessment rig} where AUC was used to control {\smb}. We note that the results in this figure are very similar to Figure~\ref{fig:tuned}, e.g., the precision deltas aver usually tiny, and false alarm increases are usually smaller than the associated recall improvements. But there are some larger improvements in Figure~\ref{fig:tuned}
than Figure~\ref{fig:auc22}. Hence, we recommend cross-measure assessment only if CPU is critically restricted. Otherwise, we think {\smb} should be controlled by whatever is the downstream evaluation criteria
(as done in the within-measure assessment rig of Figure~\ref{fig:tuned}.)



\section{Conclusion}
\label{sect:conclusion}





Prior work on ranking studies tried to improve software analytics by selecting better learners.
Our results show that there may be {\em more} benefit in exploring data pre-processors like {\smb} because we found  that no  learner  was  usually  
``best''  
across all  data  sets  and  all  evaluation  criteria. On the other hand, across the same data sets,
{\smb} was  consistently  used  by  whatever  learner  was  found  to  be ``best'' in the  AUC/recall results. And in the precision+false alarm results, there was little evidence against the use of {\smb}. That is, creating better training data  (using techniques like {\smb}) may be  more important than  the  subsequent  choice  of a classifier.


As to specific recommendations, we suggest that any prior ranking study  which did not  study the effects of data pre-processing needs to be analyzed again. Any future such ranking study should include a {\sma}-like
 pre-processor. {\sma} should not be used with its default parameters.
 For each new data set, {\sma} should be used with some automatic parameter tuning tool in
order to find the best parameters for that data set. {\smb} should be considered for parameter tuning. Ideally, {\smb} should be tuned using the evaluation criteria used to assess the final predictors. However, if there is not enough CPU to run {\smb} for each new evaluation criteria, {\smb} can be tuned using AUC. We conjecture that {\smb}
is best viewed as a   {\em signal amplifier} for regions of the data where the quality signal is weak  (e.g., sparse regions with very little data between far-flung outliers).

% One surprise from our results was that the performance improvements associated with {\smb} were not substantially different between balanced and unbalanced data sets.
%  {\sma} was originally proposed as a method to correct class imbalance, e.g., when the target class is only a small fraction of the instances in the training data.
%  Yet our results show that {\sma} (and {\smb}) is also useful for balanced data sets (and best results come from automatically tuning the control parameters of {\sma}). 


Finally, while the above results were focused on classifiers exploring defect prediction, we note that many other software analytics
tasks use classifiers:
\bi
\item Predicting Github issue close time~\cite{jones17};
\item As a pre-processor to build the tree used to 
infer quality improvement plans~\cite{krishna2017less};
\item Non-parametric sensitivity analysis~\cite{menzies2000practical};
\item Etc.
\ei
That is, potentially, {\smb} is  a sub-routine that could improve many software analytics tasks. This could be a highly fruitful direction for future research.

\section*{Acknowledgements}
The work is partially funded by
%NSF awards \#1506586  and \#1302169.
funding source (blinded for review).

\balance

%\bibliographystyle{abbrv}

\bibliographystyle{ACM-Reference-Format}
%\medskip
 \bibliography{main}


\end{document}

